"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class SearchControl {
    constructor(input, options) {
        this.options = {
            placeholder: 'Start typing...',
            minChar: 3,
            submitDelay: 300,
            noResultLabel: 'No result',
            feedbackUrl: 'https://github.com/komoot/photon/issues',
            feedbackLabel: 'Feedback',
            onSelected: undefined,
            doSearch: undefined,
        };
        this.CACHE = '';
        this.RESULTS = [];
        this.KEYS = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            TAB: 9,
            RETURN: 13,
            ESC: 27,
            APPLE: 91,
            SHIFT: 16,
            ALT: 17,
            CTRL: 18,
        };
        this.input = input;
        if (options) {
            this.options = Object.assign(this.options, options);
        }
    }
    get CURRENT() {
        return this._CURRENT;
    }
    set CURRENT(index) {
        if (typeof index === 'object') {
            index = this.resultToIndex(index);
        }
        this._CURRENT = index;
    }
    initialize() {
        this.input.type = 'search';
        if (this.options.placeholder)
            this.input.placeholder = this.options.placeholder;
        this.input.autocomplete = 'off';
        this.input.autocorrect = 'off';
        this.input.classList.add('photon-input');
        this.input.addEventListener('keydown', this.onKeyDown.bind(this));
        this.input.addEventListener('input', this.onInput.bind(this));
        this.input.addEventListener('blur', this.onBlur.bind(this));
        this.input.addEventListener('focus', this.onFocus.bind(this));
        this.createResultsContainer();
    }
    createResultsContainer() {
        this.resultsContainer = document.createElement('ul');
        this.resultsContainer.classList.add('photon-autocomplete');
        const body = document.querySelector('body');
        body === null || body === void 0 ? void 0 : body.appendChild(this.resultsContainer);
    }
    resizeContainer() {
        const l = this.getLeft(this.input);
        const t = this.getTop(this.input) + this.input.offsetHeight / 2;
        this.resultsContainer.style.left = `${l}px`;
        this.resultsContainer.style.top = `${t}px`;
        const width = this.options.width ? this.options.width : this.input.offsetWidth - 2;
        this.resultsContainer.style.width = `${width}px`;
    }
    onKeyDown(e) {
        switch (e.keyCode) {
            case this.KEYS.TAB:
                if (this.CURRENT !== null) {
                    this.setChoice();
                }
                e.stopPropagation();
                break;
            case this.KEYS.RETURN:
                e.stopPropagation();
                this.setChoice();
                break;
            case this.KEYS.ESC:
                e.stopPropagation();
                this.hide();
                this.input.blur();
                break;
            case this.KEYS.DOWN:
                if (this.RESULTS.length > 0) {
                    if (this.CURRENT !== null && this.CURRENT < this.RESULTS.length - 1) {
                        this.CURRENT += 1;
                        this.highlight();
                    }
                    else if (this.CURRENT === null) {
                        this.CURRENT = 0;
                        this.highlight();
                    }
                }
                break;
            case this.KEYS.UP:
                if (this.CURRENT) {
                    e.stopPropagation();
                }
                if (this.CURRENT && this.RESULTS.length > 0) {
                    if (this.CURRENT > 0) {
                        this.CURRENT -= 1;
                        this.highlight();
                    }
                    else if (this.CURRENT === 0) {
                        this.highlight();
                    }
                }
                break;
            default:
                break;
        }
    }
    onInput() {
        if (typeof this.submitDelay === 'number') {
            window.clearTimeout(this.submitDelay);
            this.submitDelay = null;
        }
        this.submitDelay = window.setTimeout(this.search.bind(this), this.options.submitDelay);
    }
    onBlur() {
        const self = this;
        setTimeout(() => {
            self.hide();
        }, 100);
    }
    onFocus() {
        this.input.select();
        this.search();
    }
    clear() {
        this.RESULTS = [];
        this.CURRENT = 0;
        this.CACHE = '';
        this.resultsContainer.innerHTML = '';
    }
    hide() {
        this.clear();
        this.resultsContainer.style.display = 'none';
    }
    setChoice() {
        const choice = this.RESULTS[this.CURRENT];
        if (choice) {
            this.hide();
            this.onSelected(choice);
            this.input.value = '';
        }
    }
    search() {
        const val = this.input.value;
        const minChar = (this.options.minChar && val.length >= this.options.minChar);
        if (!val || !minChar) {
            this.clear();
            return;
        }
        if (`${val}''` === `${this.CACHE}''`)
            return;
        this.CACHE = val;
        this._doSearch(val, this.handleResult.bind(this));
    }
    _doSearch(query, callback) {
        if (this.options.doSearch) {
            this.options.doSearch(query, callback);
        }
    }
    _onSelected(choise) { }
    onSelected(choice) {
        if (this.options.onSelected) {
            this.options.onSelected(choice);
        }
        else {
            this._onSelected(choice);
        }
    }
    formatResult(feature, el) {
        var _a, _b, _c, _d;
        const title = document.createElement('strong');
        el.appendChild(title);
        const detailsContainer = document.createElement('small');
        el.appendChild(detailsContainer);
        const details = [];
        const type = this.formatType(feature);
        if ((_a = feature.properties) === null || _a === void 0 ? void 0 : _a.name) {
            title.innerHTML = feature.properties.name;
        }
        else if ((_b = feature.properties) === null || _b === void 0 ? void 0 : _b.housenumber) {
            title.innerHTML = feature.properties.housenumber;
            if (feature.properties.street) {
                title.innerHTML += ` ${feature.properties.street}`;
            }
        }
        if (type)
            details.push(type);
        if (((_c = feature.properties) === null || _c === void 0 ? void 0 : _c.city) && feature.properties.city !== feature.properties.name) {
            details.push(feature.properties.city);
        }
        if ((_d = feature.properties) === null || _d === void 0 ? void 0 : _d.country)
            details.push(feature.properties.country);
        detailsContainer.innerHTML = details.join(', ');
    }
    formatType(feature) {
        var _a, _b;
        return ((_a = feature.properties) === null || _a === void 0 ? void 0 : _a.osm_value) === 'yes'
            ? feature.properties.osm_key
            : (_b = feature.properties) === null || _b === void 0 ? void 0 : _b.osm_value;
    }
    createResult(feature) {
        const el = document.createElement('li');
        this.resultsContainer.appendChild(el);
        this.formatResult(feature, el);
        const result = {
            feature,
            el,
        };
        el.addEventListener('mouseover', this.onMouseover.bind(this, result));
        el.addEventListener('mousedown', this.onMousedown.bind(this));
        return result;
    }
    onMouseover(result) {
        this.CURRENT = result;
        this.highlight();
    }
    onMousedown() {
        this.setChoice();
    }
    resultToIndex(result) {
        let out = 0;
        this.RESULTS.forEach((item, index) => {
            if (item === result) {
                out = index;
            }
        });
        return out;
    }
    handleResult(geojson) {
        const self = this;
        this.clear();
        this.resultsContainer.style.display = 'block';
        this.resizeContainer();
        geojson.features.forEach((feature) => {
            self.RESULTS.push(self.createResult(feature));
        });
        if (geojson.features.length === 0) {
            const noresult = document.createElement('li');
            noresult.classList.add('photon-no-result');
            this.resultsContainer.appendChild(noresult);
            if (this.options.noResultLabel)
                noresult.innerHTML = this.options.noResultLabel;
        }
        if (this.options.feedbackUrl) {
            const feedback = document.createElement('a');
            feedback.classList.add('photon-feedback');
            this.resultsContainer.appendChild(feedback);
            feedback.href = `${this.options.feedbackUrl}`;
            if (this.options.feedbackLabel)
                feedback.innerHTML = this.options.feedbackLabel;
        }
        this.CURRENT = 0;
        this.highlight();
    }
    highlight() {
        const self = this;
        this.RESULTS.forEach((item, index) => {
            if (index === self.CURRENT) {
                item.el.classList.add('on');
            }
            else {
                item.el.classList.remove('on');
            }
        });
    }
    getLeft(el) {
        let tmp = el.offsetLeft;
        el = el.offsetParent;
        while (el) {
            tmp += el.offsetLeft;
            el = el.offsetParent;
        }
        return tmp;
    }
    getTop(el) {
        let tmp = el.offsetTop;
        el = el.offsetParent;
        while (el) {
            tmp += el.offsetTop;
            el = el.offsetParent;
        }
        return tmp;
    }
}
exports.default = SearchControl;
//# sourceMappingURL=search-control.js.map