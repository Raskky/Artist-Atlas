"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("./base");
class PhotonGeocoding {
    constructor(map, options) {
        this.options = {
            url: 'https://photon.komoot.io/api?',
            limit: 5,
            osm_tag: undefined,
            lang: undefined,
            bbox: [],
            includePosition: true,
            location_bias_scale: 0.2,
        };
        this.map = map;
        if (options) {
            this.options = Object.assign(this.options, options);
        }
    }
    geocode(query, callback) {
        var _a;
        if (!this.options.url)
            throw new Error('No url');
        const center = this.map.getCenter();
        const zoom = this.map.getZoom() ? (_a = this.map) === null || _a === void 0 ? void 0 : _a.getZoom() : 14;
        const ajax = new base_1.default(this.options.url);
        const options = {
            q: query,
            limit: this.options.limit,
            zoom: Math.floor(zoom),
        };
        if (this.options.includePosition) {
            options.lat = center === null || center === void 0 ? void 0 : center.lat;
            options.lon = center === null || center === void 0 ? void 0 : center.lng;
            if (this.options.location_bias_scale) {
                options.location_bias_scale = this.options.location_bias_scale;
            }
        }
        if (this.options.bbox && this.options.bbox.length === 4) {
            options.bbox = this.options.bbox.join(',');
        }
        if (this.options.osm_tag) {
            options.osm_tag = this.options.osm_tag;
        }
        if (this.options.lang) {
            options.lang = this.options.lang;
        }
        ajax.request(options).then((features) => { callback(features); });
    }
}
exports.default = PhotonGeocoding;
//# sourceMappingURL=geocoding.js.map